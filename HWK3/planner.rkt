#lang racket
(require (lib "trace.ss"))
(include "./solver.rkt")

(define start-state1
  '((on(a)(table))(on(b)(table))(on(c)(a))
    (block(a))(block(b))(block(c))(clear(b))(clear(c))
    (=(a)(a))(=(b)(b))(=(c)(c))(=(table)(table))))
(define goals1 '((on(a)(b))(on(b)(c))))
(define goals2 '((on(a) x)(on x (c))))
(define actions1
  '(((move b x y)
    ((on b x)(clear b)(clear y)(block b)(block y)
     (¬(= b x))(¬(= b y))(¬(= x y)))
    ((on b y)(clear x)(¬(on b x))(¬(clear y))) )
    ((movetotable b x)
     ((on b x)(clear b)(block b)(¬(= b x))(¬(= x (table))))
     ((on b(table))(clear x)(¬(on b x)))) ))

(define (lexiographic>=? a b)
  (cond
    ((and(number? a)(number? b)) (> a b))
    ((and(symbol? a)(symbol? b)) (string>? (symbol->string a) (symbol->string b)))
    ((and(string? a)(string? b)) (string>? a b))
    ((and(pair? a)(pair? b))
     (if (equal? (car a)(car b)) (lexiographic>=? (cdr a)(cdr b))
         (lexiographic>=? (car a) (car b))))))

(define(negated-clause l) (map(λ(x)(list '¬ x))l))
(define(getbindings p) (cadr(cadr(car(reverse p)))))
(define(prove s c)
   (ATP s(list(negated-clause c))))
(define(cl l) (map list l))
(define(heuristic s)
   (length (remove* (map car (car s)) goals1)))
(define mynode (build_node (car (list(cl (sort start-state1 lexiographic>=?)))) 'start '() 0 heuristic))


(define (inconsistent -pre bind)
  (not (ormap (λ(g) (equal? (car g) (cadr g))) (map cdadr (instantiate-clause -pre bind)))))

(define (plan start goals actions)
  (define (action-quintuples action)
    (list (car action) (filter (λ(c) (not (¬? c))) (cadr action)) (filter ¬? (cadr action))
          (filter (λ(c) (not (¬? c))) (caddr action)) (filter ¬? (caddr action))  ))
  (define(cl l) (map list l))
  (define(negated-clause l) (map(λ(x)(list '¬ x))l))
  (define(getbindings p) (cadr(cadr(car(reverse p)))))
  (define(prove s c)
    (ATP s(list(negated-clause c))))
  (define(heuristic s)
   (length (remove* (map car (car s)) goals)))
  (define(move-action a node)
        (let((action-name (car a))
         (+pre (cadr a))
         (-pre (caddr a))
         (results (cadddr a))
         (deletes (map cadr(car(cddddr a)))) )
      (map(λ(e) (build_node (list (sort (map list (append (instantiate-clause results e) 
                                             (remove* (instantiate-clause deletes e) (map car (car (puzzle_node-state node))))))
                           lexiographic>=?) '()) (instantiate-clause action-name e) node (+ (puzzle_node-g node) 1) heuristic))
                (filter (λ(bind) (inconsistent -pre bind))
                        (map getbindings
                             (prove(car (puzzle_node-state node)) +pre) )))))
  (define(moves node)
        (append-map(λ(act) (move-action (action-quintuples act) node)) actions))
  (define(goal? s)
    (not(null? (prove (car s) goals))))
  (time(2ndA*-graph-search (list(cl (sort start lexiographic>=?))) goal? moves heuristic)))

(trace)